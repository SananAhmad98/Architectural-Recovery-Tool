

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author MOD
 */

public class ExtractInformation extends javax.swing.JFrame {
    private Object ArrayListMultimap;

    /**
     * Creates new form PathForm
     */
    public ExtractInformation() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        ok = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        label1 = new java.awt.Label();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        ok.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        ok.setText("Browse");
        ok.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Serif", 3, 14)); // NOI18N
        jLabel1.setText("              ARCHITECTURAL RECOVERY");

        label1.setFont(new java.awt.Font("Dialog", 1, 12)); // NOI18N
        label1.setText("Note: Select any Java File or Folder");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(56, 56, 56)
                        .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(79, 79, 79)
                        .addComponent(ok))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(101, 101, 101)
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 290, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(122, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(104, 104, 104)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ok))
                .addContainerGap(278, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void okActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okActionPerformed
        // TODO add your handling code here:

        boolean fileExist=false;

        JFileChooser fc=new JFileChooser();
        fc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);

        int i=fc.showOpenDialog(this);

        if(i==JFileChooser.APPROVE_OPTION){
            file=fc.getSelectedFile();
            String filepath=file.getPath();
            //  System.out.println("Input Text :- "+filepath);
            fileExist=file.exists();

            if(file.isFile()&&fileExist)
            {
                projectName= "N/A" ;
                className= file.getName();

                try
                {
                    s1=new Scanner(file);
                    s2=new Scanner(file);
                }
                catch (FileNotFoundException ex)
                {
                    Logger.getLogger(ExtractInformation.class.getName()).log(Level.SEVERE, null, ex);
                }
                while(s1.hasNextLine())
                {
                    words.add(s1.next());  //this types has a whole file in it
                }

                getClassesInfo();  // to get the name and type of all classes in a file.

                while(s2.hasNextLine())
                {
                    lines.add(s2.nextLine());   // stores file line by line
                }

                getMethodsInfo(); // to get all info about methods in a file.
                getVariablesInfo(); // to get whole info about class attributes in a file.
                getArrayListInfo(); // to get whole info about arrayLists in a class.
                getGeneraliztionRelations(); // to get all the generalization relations in a single file
                displayInfo(); // to get whole printed.

                DrawClassDiagram dcg = new DrawClassDiagram(fileTypes,fileNames, methodReturn,methodNames,variableReturn,variableNames,fileRecordMethods,fileRecordVariables,compositionRelationWith,compositionRelationHas,aggregationRelationWith,aggregationRelationHas,generalizationParent,generalizationChild); // to draw class diagrams of all classes.

           
            
            }
            else if(fileExist && file.isDirectory())   // when the input is folder
            {
                projectName= file.getName();   //this will give project folder name
                for(File foldername : file.listFiles())
                {

                    if(((foldername.isDirectory() )&& ((foldername.getName().contains("Source")) || (foldername.isDirectory() && foldername.getName().contains("src") ) || (foldername.isDirectory() && foldername.getName().contains("source") ) || (foldername.isDirectory() && foldername.getName().contains("Src") )  )))
                    {
                        for(File filename : foldername.listFiles())
                        {     //source files one by one
                            className = filename.getName();
                            file2 = new File(filename.getAbsolutePath());
                            try
                            {
                                s1=new Scanner(file2);  //get absolute path of java file.
                            }
                            catch (FileNotFoundException ex)
                            {
                                Logger.getLogger(ExtractInformation.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try
                            {
                                s2=new Scanner(file2);
                            }
                            catch (FileNotFoundException ex)
                            {
                                Logger.getLogger(ExtractInformation.class.getName()).log(Level.SEVERE, null, ex);
                            }

                            while(s1.hasNextLine())
                            {
                                words.add(s1.next());  //this has a whole file in it
                            }

                            getClassesInfo();  // to get the name and type of all classes in a file.

                            while(s2.hasNextLine())
                            {
                                lines.add(s2.nextLine());   // stores file line by line.
                            }

                            words.clear(); // after every file turn, clear the words and lines array list.
                            lines.clear();

                        } // to extract all classes detail first.

                        for(File filename : foldername.listFiles()){ // to get methods,variables,arraylists.

                            className = filename.getName();
                            file2 = new File(filename.getAbsolutePath());

                            try
                            {
                                s1=new Scanner(file2);  //get absolute path of java file.
                            }
                            catch (FileNotFoundException ex)
                            {
                                Logger.getLogger(ExtractInformation.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try
                            {
                                s2=new Scanner(file2);
                            }
                            catch (FileNotFoundException ex)
                            {
                                Logger.getLogger(ExtractInformation.class.getName()).log(Level.SEVERE, null, ex);
                            }

                            while(s1.hasNextLine())
                            {
                                words.add(s1.next());  //this has a whole file in it
                            }

                            while(s2.hasNextLine())
                            {
                                lines.add(s2.nextLine());   // stores file line by line.
                            }

                            getMethodsInfo(); // to get all info about methods in a file.
                            getVariablesInfo(); // to get whole info about class attributes in a file.
                            getArrayListInfo(); // to get whole info about folder array Lists
                            getGeneraliztionRelations(); // to get all the generalization relations in a single file

                            words.clear(); // after every file turn, clear the words and lines array list.
                            lines.clear();

                        }

                        displayInfo(); // to get whole printed.
                        
                        DrawClassDiagram dcg = new DrawClassDiagram(fileTypes,fileNames, methodReturn,methodNames,variableReturn,variableNames,fileRecordMethods,fileRecordVariables,compositionRelationWith,compositionRelationHas,aggregationRelationWith,aggregationRelationHas,generalizationParent,generalizationChild); // to draw class diagrams of all classes.

                  

                        
                    } // if for source folder

                }
            }

        }

    }//GEN-LAST:event_okActionPerformed

      Scanner s1; // to read a single file chracter by character especially for file as a whole
      Scanner s2; // to read single file line by line especially for methods
      
      File file;
      File file2;
    
      ArrayList<String> words = new ArrayList<>(); //store file word by word / for class overall
      ArrayList<String> lines = new ArrayList<>(); //store file line by line / for methods or variables
      
      String projectName; //to store project name
      String className; //to store fileName.
      
      ArrayList<String> methodNames = new ArrayList<>();//stores method names
      ArrayList<String> methodTypes = new ArrayList<>() ;// stores method types
      ArrayList<String> methodReturn = new ArrayList<>();
      
      ArrayList<String> variableNames = new ArrayList<>(); //stores variable names
      ArrayList<String> variableTypes = new ArrayList<>();// stores variable types
      ArrayList<String> variableReturn = new ArrayList<>();
      
      int recordMethod =-1;  //to keep track the record of classes variables
      int recordVariable =-1; //to keep the track record of classes variables
      int recordArrayList = -1; // to keep track record of classes arraylists.
      
      ArrayList<String> fileNames = new ArrayList<>(); // to store file Names
      ArrayList<String> fileTypes = new ArrayList<>(); // to store file types.
      
      ArrayList<Integer> fileRecordVariables = new ArrayList<>(); // to store class number for variables.
      ArrayList<Integer> fileRecordMethods =new ArrayList<>(); // to store class number for methods.
      
      ArrayList<String> compositionRelationWith = new ArrayList<>(); // class to which composition is with.
      ArrayList<String> compositionRelationHas = new ArrayList<>(); // in which variable lies.
      
        ArrayList<String> aggregationRelationWith = new ArrayList<>(); // class to which aggregation is with.
      ArrayList<String> aggregationRelationHas = new ArrayList<>(); //class in which the Array lies.
      
      ArrayList<String> generalizationParent = new ArrayList<>(); // class which is parent.
      ArrayList<String> generalizationChild = new ArrayList<> (); // class which is child.
  
       
     
       
      
      
      public void getClassesInfo(){
          
       
          
             for(int i=0; i< words.size() ; i++){  
                           
                           if("abstract".equals(words.get(i)) && "class".equals(words.get(i+1))){ //when the class is abstract class
                             
                         
                              fileNames.add(words.get(i+2).replace("{", ""));
                             fileTypes.add("Abstract");
                               
                           }
                           else if("class".equals(words.get(i)) && (!"abstract".equals(words.get(i-1)) )){ //when the class is normal class
                               
                                 
                               fileNames.add( words.get(i+1).replace("{", ""));
                               fileTypes.add("Normal");
                              
                           }
                       }  // till this class types and names has been notified.
          
          
          
      } // getClassesInfo() ends here
      
   
      public void getMethodsInfo(){
          
          int classNo = -1;
         
          
             for(int j=0 ;  j < lines.size() ;j++ ){  // to get the method type and method name
                 
                           if(lines.get(j).contains(" class ")){  // to check which class is this first, second and so on.
                               
                               classNo ++;
                               recordMethod++;
                               
                           }
                            
                           
                           if( ( (lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected")) ) && ((lines.get(j).contains("void")) || (lines.get(j).contains("int")) || (lines.get(j).contains("double")) || (lines.get(j).contains("float")) || (lines.get(j).contains("String")) || (lines.get(j).contains("boolean")) || (lines.get(j).contains("char"))) && ((lines.get(j).contains("(")) && (lines.get(j).contains(")"))) &&  (! lines.get(j).contains("main") ) && (!lines.get(j).contains(" class ")) && (getValidMethod(lines.get(j)) )) {
                           
                              fileRecordMethods.add(recordMethod);
                              
                          
                               
                            String[]   methodInfoSp = lines.get(j).split(" ");  //split the method signature in words.
                               
                               
                               for(int k=0; k < methodInfoSp.length; k++){
                                 
                                
                                 if(methodInfoSp[k].contains("public") || methodInfoSp[k].contains("private") || methodInfoSp[k].contains("protected") ){ // to get method type
                                     
                                   methodTypes.add(methodInfoSp[k]);
                               
                                   
                                 }
                                 
                                 
                               if(("void".equals(methodInfoSp[k]) || "int".equals(methodInfoSp[k]) || "double".equals(methodInfoSp[k]) || "float".equals(methodInfoSp[k]) || "String".equals(methodInfoSp[k]) || "boolean".equals(methodInfoSp[k]) || "char".equals(methodInfoSp[k])) && (!(methodInfoSp[k+1].contains("main") )) && (getValidMethodName(methodInfoSp[k+1]))){   // to get method name
                                   
                                methodReturn.add(methodInfoSp[k]);
                                methodInfoSp[k+1] = methodInfoSp[k+1].replace("{", " ");
                                  
                                
                                methodNames.add(methodInfoSp[k+1]);
                                 
                               }
                          
                               } //inner for-loop ends here      
                           } // first if-when methods are of primitve type.
                           
                           else if( ((lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected")) ) && ((!lines.get(j).contains("void") && (!lines.get(j).contains("int")) && (!lines.get(j).contains("double")) && (!lines.get(j).contains("float")) && (!lines.get(j).contains("String")) && (!lines.get(j).contains("boolean")) && (!lines.get(j).contains("char")))) && ((lines.get(j).contains("(")) && (lines.get(j).contains(")"))) &&  (! lines.get(j).contains("main")) && (!lines.get(j).contains(" class "))){  // if the method has non-primitive
                         
                              
                               if((lines.get(j).contains("static") && (!lines.get(j).contains("final"))) || (!lines.get(j).contains("static") && (lines.get(j).contains("final")))){ // if-when either static or final keyword exist.
                                   
                                   
                             
                            String[]   methodInfoSp = lines.get(j).split(" ");  //split the method signature in words.
                               
                               
                     for(int k=0; k < methodInfoSp.length; k++){
                                 
                                
                   if(methodInfoSp[k].contains("public") || methodInfoSp[k].contains("private") || methodInfoSp[k].contains("protected") ){ // to get method type
                                     
                         boolean result;
                         result = checkIfClassExist(methodInfoSp[k+2]); // to check if class exist or not.
                                     
                          if(result == true){
                         
                              
                                fileRecordMethods.add(recordMethod);
                                 methodTypes.add(methodInfoSp[k]);
                                 methodReturn.add(methodInfoSp[k+2]);
                                 methodInfoSp[k+3] = methodInfoSp[k+3].replace("{", " ");
                                 methodNames.add(methodInfoSp[k+3]);
                               
                                   
                                     }
                                 
                                 } // inner if ends here
                                      
                               } // inner-for loop ends here
                                   
                           } // if-when either final or static keyword exist within method signature. 
                               
                            else if(lines.get(j).contains("static") && lines.get(j).contains("final")){  // compostion case-when both static and final exist.
                               
                                 
                            String[]   methodInfoSp = lines.get(j).split(" ");  //split the method signature in words.
                               
                               
                               for(int k=0; k < methodInfoSp.length; k++){
                                 
                                
             if(methodInfoSp[k].contains("public") || methodInfoSp[k].contains("private") || methodInfoSp[k].contains("protected") ){ // to get method type
                                     
                                     
                         boolean result;
                         result = checkIfClassExist(methodInfoSp[k+3]); // to check if class exist or not.
                         
                         if(result == true){
                                     
                             
                                fileRecordMethods.add(recordMethod);
                                 methodTypes.add(methodInfoSp[k]);
                                 methodReturn.add(methodInfoSp[k+3]);
                                 methodInfoSp[k+4] = methodInfoSp[k+4].replace("{", " ");
                                 methodNames.add(methodInfoSp[k+4]);
                               
                         }
                         
                         
                                 } // inner-if ends
                                      
                               } // inner for loop ends here.
                                   
                          
                               } // else if-when both static and final exist
                               
                               
                            else if((!lines.get(j).contains("static")) && (!lines.get(j).contains("final"))){ // when niether final nor static keyword exists.
                                
                                
                            String[]   methodInfoSp = lines.get(j).split(" ");  //split the method signature in words.
                                
                                
                               for(int k=0; k < methodInfoSp.length; k++){
                                 
                                
             if(methodInfoSp[k].contains("public") || methodInfoSp[k].contains("private") || methodInfoSp[k].contains("protected") ){ // to get method type
                                     
                                     
                         boolean result;
                         result = checkIfClassExist(methodInfoSp[k+1]); // to check if class exist or not.
                         
                         if(result == true){
                                     
                             
                                fileRecordMethods.add(recordMethod);
                                 methodTypes.add(methodInfoSp[k]);
                                 methodReturn.add(methodInfoSp[k+1]);
                                 methodInfoSp[k+2] = methodInfoSp[k+2].replace("{", " ");
                                 methodNames.add(methodInfoSp[k+2]);
                               
                         }
                         
                         
                                 } // inner-if ends
                                      
                               } // inner for loop ends here.
                                    
                            }
                             
                       } // else-if of non-primitive method
         
      } //outer for loop ends here
      
      } //getWholeMethodInfo ends here.
         
      public boolean getValidMethod(String methodName){  // to check while counting.
          
          boolean isMethod = true;
       
          
          for(int i=0 ; i < fileNames.size() ; i++){
              
              if(methodName.contains(fileNames.get(i))){
                  
                  isMethod = false;
                  break;
              }
             
          } // for loop ends here
          
          return isMethod;
        
      } // get valid method
      
      
      public boolean getValidMethodName(String methodName){   // to check whether the method is constructor or not.
          
          boolean isMethod = true;
          
          if(fileNames.contains(methodName)){
              
              isMethod = false;
              
          }
          
          
          return isMethod;
          
      } //get Valid Method Name ends here.
      
   
      
      
      public void getVariablesInfo(){
          
          int classNo = -1;
          
     
          for(int j=0; j< lines.size() ; j++){
     
              if(lines.get(j).contains(" class ")){   // for the separation of classes.
                  
                  classNo++;
                  recordVariable++;
                 
              }
              
       
              if(  ((lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected")) ) && ( lines.get(j).contains("char")  || lines.get(j).contains("boolean") || lines.get(j).contains("int") || lines.get(j).contains("double") || lines.get(j).contains("float") || lines.get(j).contains("String") ) && (lines.get(j).contains(";")) && ( (!lines.get(j).contains(")")) && (!lines.get(j).contains("(")) )  ){
               
                  
                  fileRecordVariables.add(recordVariable); // to store the number of file which includes variable.
                  
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                  
                    
                     for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                                 if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                     
                                   variableTypes.add(VariableInfoSp[k]);
                               
                                 }
                                 
                                 if( ("int".equals(VariableInfoSp[k]) || "double".equals(VariableInfoSp[k]) || "float".equals(VariableInfoSp[k]) || "String".equals(VariableInfoSp[k]) || "boolean".equals(VariableInfoSp[k]) || "char".equals(VariableInfoSp[k]) ) && (!(VariableInfoSp[k+1].contains("main") )) && (!(VariableInfoSp[k+1].contains(className)))){
                                     
                                           variableReturn.add(VariableInfoSp[k]);
                                          VariableInfoSp[k+1] = VariableInfoSp[k+1].replace(";", " ");
                                          variableNames.add(VariableInfoSp[k+1]);
                                         
                                         
                                 }
                  
              } // inner loop ends here
               
          } // first if , when the data type is primitive.
              
              else if(( (lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected"))) && (!( lines.get(j).contains("char")  && lines.get(j).contains("boolean") && lines.get(j).contains("int") && lines.get(j).contains("double") && lines.get(j).contains("float") && lines.get(j).contains("String"))) && (lines.get(j).contains(";")) && ( (!lines.get(j).contains(")")) && (!lines.get(j).contains("(")) )  ){ // when the data type is non-primitive.
                  
                  if((lines.get(j).contains("static") && (!lines.get(j).contains("final"))) || (!lines.get(j).contains("static") && (lines.get(j).contains("final"))) ){
                  
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                    
            
                     for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                  if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                
                         boolean result;
                         result = checkIfClassExist(VariableInfoSp[k+2]); // to check if class exist or not.
                         
                         if(result == true){
                             
                  fileRecordVariables.add(recordVariable); // to store the number of file which includes variable. 
                                   variableTypes.add(VariableInfoSp[k]);
                                   variableReturn.add(VariableInfoSp[k+2]);
                                   VariableInfoSp[k+3] = VariableInfoSp[k+3].replace(";", " ");
                                          variableNames.add(VariableInfoSp[k+3]);
                                          
                                          if(lines.get(j).contains(" final ")){
                                          
                                          compositionRelationWith.add(VariableInfoSp[k+2]);
                                          compositionRelationHas.add(fileNames.get(recordVariable));
                                          
                                          }
                                          else if(!lines.get(j).contains(" final ")){
                                              
                                          aggregationRelationWith.add(VariableInfoSp[k+2]);
                                          aggregationRelationHas.add(fileNames.get(recordVariable));
                                              
                                              
                                          }
                         }
                  }
                                 
                                
                  
              } // inner loop ends here
                  
                  } // when final or static keyword does exist. 
                  
                  else if (lines.get(j).contains("static") && lines.get(j).contains("final")){ // when both exist at same time.
                      
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                    
            
                     for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                                 if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                     
                                     boolean result;
                                     result = checkIfClassExist(VariableInfoSp[k+3]); // to check if class exist or not.
                                     
                                     if(result == true){ 
                                     
                                      fileRecordVariables.add(recordVariable); // to store the number of file which includes variable.
                                         
                                   variableTypes.add(VariableInfoSp[k]);
                                variableReturn.add(VariableInfoSp[k+3]);                                  
                                   VariableInfoSp[k+4] = VariableInfoSp[k+4].replace(";", " ");
                                          variableNames.add(VariableInfoSp[k+4]);
                               
                                         
                                          
                                          compositionRelationWith.add(VariableInfoSp[k+3]);  //add non-primitive type.
                                          compositionRelationHas.add(fileNames.get(recordVariable));
                                 
                                     }
                                 }
                                 
                        
                     } // inner-loop ends here.
                     
                     } //else-if when both final and static keywords do exist at the same time.
                  
                  else if((!lines.get(j).contains("static")) && (! lines.get(j).contains("final"))){ //when niether final nor static exists.
                      
                         String[]   VariableInfoSp = lines.get(j).split(" ");
                         
                          for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                                 if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                     
                                     boolean result;
                                     result = checkIfClassExist(VariableInfoSp[k+1]); // to check if class exist or not.
                                     
                                     if(result == true){ 
                                     
                                      fileRecordVariables.add(recordVariable); // to store the number of file which includes variable.
                                         
                                   variableTypes.add(VariableInfoSp[k]);
                                 variableReturn.add(VariableInfoSp[k+1]);    
                                   VariableInfoSp[k+2] = VariableInfoSp[k+2].replace(";", " ");
                                          variableNames.add(VariableInfoSp[k+2]);
                               
                                         
                                          
                                          aggregationRelationWith.add(VariableInfoSp[k+1]);  //add non-primitive type.
                                          aggregationRelationHas.add(fileNames.get(recordVariable));
                                 
                                     }
                                 }
                                 
                        
                     } // inner-loop ends here.
                           
                  } // else if - when niether final nor static keyword exists.
                  
              } // else-if for the variables whose type is non-primitive.
         
      } // outer for loop ends here
              
      } // get variable info ends here
      
        public void getArrayListInfo(){ //getArrayListInfo starts here.
          
           int classNo = -1;
          
     
          for(int j=0; j< lines.size() ; j++){
     
              if(lines.get(j).contains(" class ")){   // for the separation of classes.
                  
                  classNo++;
                  recordArrayList++;
               
                 
              }
          
              if(  ((lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected")) )  &&lines.get(j).contains("ArrayList") && (lines.get(j).contains("<Integer>") || lines.get(j).contains("<String>") || lines.get(j).contains("<Character>") || lines.get(j).contains("<Double>") || lines.get(j).contains("<Float>") || lines.get(j).contains("<Boolean>") ) &&  lines.get(j).contains("<>") && lines.get(j).contains(" new ") ){ // primitve type for the ArrayList ends here.
                  
              
                  
                   fileRecordVariables.add(recordArrayList); // to store the number of file which includes variable.
                  
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                  
                       for(int k=0; k < VariableInfoSp.length; k++){
                        
                                 if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                     
                                   variableTypes.add(VariableInfoSp[k]);
                                  
                                      
                                 }
                                 /*else if(!VariableInfoSp[k].contains("public") && !VariableInfoSp[k].contains("private") && !VariableInfoSp[k].contains("protected")) {
                                     
                                     variableTypes.add("Default");
                                 }*/
                                 
                                 if( (VariableInfoSp[k].contains("=") ) ){
                                     
                                          
                                         variableReturn.add(VariableInfoSp[k-2]);
                                          variableNames.add(VariableInfoSp[k-1]);
                                         
                                         
                                 }
                  
              } // inner loop ends here
                        
              } // when the data types are primitive.
              
              else if(((lines.get(j).contains("public")) || (lines.get(j).contains("private")) || (lines.get(j).contains("protected"))) && lines.get(j).contains("ArrayList") && ((!lines.get(j).contains("<Integer>") && (!lines.get(j).contains("<String>")) && (!lines.get(j).contains("<Character>")) && (!lines.get(j).contains("<Double>")) && (!lines.get(j).contains("<Float>")) && (!lines.get(j).contains("<Boolean>")))) && (lines.get(j).contains("<>")) && (lines.get(j).contains(" new "))  ){
                  
                 
                   if((lines.get(j).contains(" static ") && (!lines.get(j).contains(" final "))) || (!lines.get(j).contains(" static ") && (lines.get(j).contains(" final "))) ){  // if - when either static or final exists
                 
                       
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                  
                      for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                  if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                 
                      
                         boolean result=false;
                         String targetClass=null;
                        
                         for(int e=0; e< VariableInfoSp.length ; e++){
                         
                        if(VariableInfoSp[e].contains("=")){
                                   
                        
                              targetClass=extractClassName(VariableInfoSp[e-2]);
                            
                         }
                        
                         }
                         result = checkIfClassExist(targetClass); // to check if class exist or not.
                         
                         if(result == true){
                             
                  fileRecordVariables.add(recordArrayList); // to store the number of file which includes variable. 
                                   variableTypes.add(VariableInfoSp[k]);
                                    
                                 for(int f=0; f < VariableInfoSp.length ; f++){
                                     
                                        if(VariableInfoSp[f].contains("=")){
                                        
                                            variableReturn.add(VariableInfoSp[f-2].replace("ArrayList",""));
                                            variableNames.add(VariableInfoSp[f-1]);
                                        
                                        
                                        }
                                 }   
                                 
                                        if(!lines.get(j).contains(" final ")){
                                         
                                            aggregationRelationWith.add(targetClass);
                                          aggregationRelationHas.add(fileNames.get(recordArrayList));
                                        
                                        }
                                        
                                        else if(lines.get(j).contains(" final ")){
                                            
                                             compositionRelationWith.add(targetClass);
                                             compositionRelationHas.add(fileNames.get(recordArrayList));
                                            
                                        }
                         }  // if - after checkIf class exist
                  } // inner if ends here.
                                 
                                
                  
              } // inner loop ends here
                  
                  
                   } // if - when either static or final keyword exist in arrayList
                   
                   else if (lines.get(j).contains(" static ") && lines.get(j).contains(" final ")){ // when both static and final keyword exists
                       
                          
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                  
                      for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                  if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                 
                      
                         boolean result=false;
                         String targetClass=null;
                        
                         for(int e=0; e< VariableInfoSp.length ; e++){
                         
                        if(VariableInfoSp[e].contains("=")){
                                   
                        
                              targetClass=extractClassName(VariableInfoSp[e-2]);
                            
                         }
                        
                         }
                         result = checkIfClassExist(targetClass); // to check if class exist or not.
                         
                         if(result == true){
                             
                  fileRecordVariables.add(recordArrayList); // to store the number of file which includes variable. 
                                   variableTypes.add(VariableInfoSp[k]);
                                    
                                 for(int f=0; f < VariableInfoSp.length ; f++){
                                     
                                        if(VariableInfoSp[f].contains("=")){
                                          
                                            variableReturn.add(VariableInfoSp[f-2].replace("ArrayList",""));
                                            variableNames.add(VariableInfoSp[f-1]);
                                        
                                        }                              
                                 }   
                                          compositionRelationWith.add(targetClass);
                                          compositionRelationHas.add(fileNames.get(recordArrayList));
                              
                         }
                  } // inner if ends here.
                                 
                                
                  
              } // inner loop ends here
                       
                       
                       
                       
                   } // else if- when both final and static exist
                   
                    else if((!lines.get(j).contains(" static ")) && (! lines.get(j).contains(" final "))){ // when niether static nor final keyword exist.
                        
                               
                    String[]   VariableInfoSp = lines.get(j).split(" ");
                  
                      for(int k=0; k < VariableInfoSp.length; k++){
                                 
                                
                  if(VariableInfoSp[k].contains("public") || VariableInfoSp[k].contains("private") || VariableInfoSp[k].contains("protected") ){ // to get variable type
                                 
                      
                         boolean result=false;
                         String targetClass=null;
                        
                         for(int e=0; e< VariableInfoSp.length ; e++){
                         
                        if(VariableInfoSp[e].contains("=")){
                                   
                        
                              targetClass=extractClassName(VariableInfoSp[e-2]);
                            
                         }
                        
                         }
                         result = checkIfClassExist(targetClass); // to check if class exist or not.
                
                         if(result == true){
                             
                  fileRecordVariables.add(recordArrayList); // to store the number of file which includes variable. 
                                   variableTypes.add(VariableInfoSp[k]);
                                    
                                 for(int f=0; f < VariableInfoSp.length ; f++){
                                     
                                        if(VariableInfoSp[f].contains("=")){
                                          variableReturn.add(VariableInfoSp[f-2].replace("ArrayList",""));
                                            variableNames.add(VariableInfoSp[f-1]);
                                        }
                                 }   
                                          aggregationRelationWith.add(targetClass);
                                          aggregationRelationHas.add(fileNames.get(recordArrayList));
                              
                         }
                  } // inner if ends here.
                                 
                                
                  
              } // inner loop ends here
                            
                        
                    } //else if - when niether static nor final keyword exist ends here
                   
                   
                  
              } //Main else if - when there is a primitive type of arrayList
       
              
              
          } // outer loop ends here
          
          
          
          
          
      } // getArrayListInfo ends here
      
      
          
      public String extractClassName(String str){ //extracts class name from non primitive array list
          
        
          String result="";
          
          char [] inCharacters = str.toCharArray();
          
          for(int i=0; i< inCharacters.length ; i++){
           
              if(inCharacters[i] == '<'){
                  
                  while(inCharacters[i+1] != '>'){
                      
                      result  = result.concat(Character.toString(inCharacters[i+1]));
                      i++;
                  
                  }
                  break;
              }
          }
         
          return result;
          
      } // extaract class name ends here.
      
      
      
      public boolean checkIfClassExist(String dataType){ // check if non-primitive type exist.
          
          boolean result = false;
          
          if(fileNames.contains(dataType)){
              
              result = true;
          }
          
          return result;
      
      } // checkIfClassExist ends here.
      
      
      public void getGeneraliztionRelations(){ // to get all the generalization relations in a file.
          
          
          for (int i=0; i < words.size() ; i++){
              
              if("extends".equals(words.get(i))){
                  
                  if(fileNames.contains(words.get(i+1).replace("{",""))){
                  
                      generalizationParent.add(words.get(i+1).replace("{",""));
                  
                  }
                  
                  generalizationChild.add(words.get(i-1));
                  
              }
              
          }
          
      } // getGeneralizationRelation ends here.
      
      
      
      
      
      public void displayInfo(){  // to display all the information.
     
          //System.out.println(variableTypes.size());
          
         
           if(fileRecordMethods.contains(0))
              {
                  //System.out.println("Contain 1");
              }
           else{
               //System.out.println("not COntain");
           }
           ArrayList<String> [] MET=new ArrayList[fileNames.size()];
           ArrayList<String> [] METY=new ArrayList[fileNames.size()];
           ArrayList<String> [] VL=new ArrayList[fileNames.size()];
           ArrayList<String> [] VLT=new ArrayList[fileNames.size()];
            
           Tables OB=new Tables();
           //OB.Tables(words, words, words, words, className);
           for (int i = 0; i < fileNames.size(); i++)
           {
               MET[i]=new ArrayList<String>();
               METY[i]=new ArrayList<String>();
               
               
               
               //System.out.println("File Name :- "+fileNames.get(i));
               //System.out.println("\tMethods :-");
                if(fileRecordMethods.contains(i))
                    {
                            //System.out.println("Contain "+i);
                            for (int j = 0; j < fileRecordMethods.size(); j++)
                            {
                                if(fileRecordMethods.get(j)==i)
                                  {
                                      //System.out.println("Form Loop "+methodNames.get(j)+"\t Type :- "+methodTypes.get(j));
                                        MET[i].add(methodNames.get(j));
                                        METY[i].add(methodTypes.get(j));
                                  }
                            }
                    }
                else{
                 //    System.out.println("not COntain");
                }
                
                //System.out.println("\tVaribles :-");
                if(fileRecordVariables.contains(i))
                    {
                        VL[i]=new ArrayList<String>();
                        VLT[i]=new ArrayList<String>();
                  //       System.out.println("Contain "+i);
                            for (int j = 0; j < fileRecordVariables.size(); j++)
                            {
                                if(fileRecordVariables.get(j)==i)
                                  {
                    //                  System.out.println("Form Loop "+variableNames.get(j)+"\t Type :- "+variableTypes.get(j));
                                        VL[i].add(variableNames.get(j));
                                        VLT[i].add(variableTypes.get(j));
                                  }
                            }
                    }
                else
                    {
                      //  System.out.println("Not Contain Varibles");
                    }
               OB.Tables(VL[i],VLT[i],MET[i],METY[i],""+fileNames.get(i)+":"+fileTypes.get(i));
          }
        //new Tables(variableNames,variableTypes,"Hellow");
        int countMethods=0;
        int countVariables=0;
        int countFiles = 0;
        
        countFiles = fileNames.size();
         
          System.out.println("Project Name: "+projectName);
          System.out.println(" ");
          //System.out.println("No of Classes: "+countFiles);
          
//          for(int i=0; i < fileNames.size() ; i++){
//              
//              System.out.println(" ");
//              System.out.println("File Name: "+fileNames.get(i)+".java"+"   "+fileTypes.get(i));
//              System.out.println(" ");
//              System.out.println("Methods:");
//              
//              for(int j=0; j < fileRecordMethods.size() ; j++ ){
//                  
//                  if(i == fileRecordMethods.get(j)){
//                      
//                      System.out.println(methodNames.get(j)+""+methodTypes.get(j)); 
//                      countMethods++;
//                  }
//              }
//        
//          } // method display outer loop ends here
//              
//       for(int k=0; k < fileNames.size() ; k++){
//              
//              System.out.println(" ");
//              System.out.println("File Name: "+fileNames.get(k)+".java"+"   "+fileTypes.get(k));
//              System.out.println(" ");
//              System.out.println("Variables:");
//              
//              for(int l=0; l < fileRecordVariables.size() ; l++ ){
//                  
//                  if(k == fileRecordVariables.get(l)){
//                      
//                      
//                      System.out.println(variableNames.get(l)+""+variableTypes.get(l));
//                      countVariables++;
//                      
//                  }
//              }
//            
//          } // variable display outer loop ends here.
               
               
               //Now, display the composition relations

          
                if(aggregationRelationHas.size() > 0){
             
                   System.out.println("");
               System.out.println("Aggregation Relations:");
               System.out.println("");
              
               for(int c = 0 ; c < aggregationRelationHas.size() ; c++){
                   
                   System.out.println(aggregationRelationHas.get(c)+".java"+" has aggregation relation with "+aggregationRelationWith.get(c)+".java");
                   
               }
               
               } // composition display ends here.

          
               if(compositionRelationHas.size() > 0){
             
                   System.out.println("");
               System.out.println("Composition Relations:");
               System.out.println("");
              
               for(int c = 0 ; c < compositionRelationHas.size() ; c++){
                   
                   System.out.println(compositionRelationHas.get(c)+".java"+" has composition relation with "+compositionRelationWith.get(c)+".java");
                   
               }
               
               } // composition display ends here.
               
               
               if(generalizationParent.size() > 0){
                   
                   
                   System.out.println("");
               System.out.println("Generalization Relations:");
                    System.out.println("");
                    
                    for(int d = 0 ; d < generalizationParent.size() ; d++){
                   
                   System.out.println(generalizationParent.get(d)+".java"+" is a parent of "+generalizationChild.get(d)+".java");
                   
               }
                   
                   
                   
               } // generalization ends here.
               
      } // displayInfo function ends here.
      
      
    String PN="";        
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ExtractInformation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ExtractInformation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ExtractInformation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ExtractInformation.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ExtractInformation().setVisible(true);
            }
        });
        
        
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private java.awt.Label label1;
    private javax.swing.JButton ok;
    // End of variables declaration//GEN-END:variables
}
